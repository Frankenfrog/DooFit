/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "DooCubicSplinePdf.h" 

// STD & STL
#include <cmath>
#include <complex>
#include <iterator>
#include <algorithm>
#include <sstream>

// ROOT
#include <TMath.h>
#include <TH1.h>
#include <TGraph.h>
#include <TGraphErrors.h>

// RooFit
#include <RooFit.h>
#include <Riostream.h>
#include <RooMath.h>
#include <RooAbsReal.h>
#include <RooRealVar.h>
#include <RooConstVar.h>
#include <RooArgList.h>

// Splines
#include "P2VV/RooCubicSplineKnot.h"

using namespace std;

ClassImp(doofit::roofit::pdfs::DooCubicSplinePdf) 

namespace doofit {
namespace roofit {
namespace pdfs {

  DooCubicSplinePdf::DooCubicSplinePdf()
      : _aux(0,0)
  {
  }

  DooCubicSplinePdf::DooCubicSplinePdf(const std::string name,
                                       RooRealVar& x, 
                                       const vector<double>& knots,
                                       const RooArgList& coefList,
                                       double range_min,
                                       double range_max):
    RooAbsPdf(name.c_str(), name.c_str()),
    _x("x", "Dependent", this, x),
    _coefList("coefficients", "List of coefficients", this),
    _aux(knots.begin(), knots.end()),
    _use_range(true),
    _range_min(range_min),
    _range_max(range_max)
  {
     assert(size_t(coefList.getSize()) == 2 + knots.size());
     _coefList.add(coefList);
  }

  DooCubicSplinePdf::DooCubicSplinePdf(const std::string name,
                                       RooRealVar& x, 
                                       const vector<double>& knots,
                                       const RooArgList& coefList):
    DooCubicSplinePdf(name, x, knots, coefList, 0, 0)
  {
    _use_range = false;
  }

  DooCubicSplinePdf::DooCubicSplinePdf(const DooCubicSplinePdf& other, const char* name) :
    RooAbsPdf(other, name),
    _x("x", this, other._x),
    _coefList("coefList", this, other._coefList),
    _aux(other._aux)
  {
  }

  DooCubicSplinePdf::~DooCubicSplinePdf()
  {
  }

  Double_t DooCubicSplinePdf::evaluate() const
  {
    if (_use_range){
      if ((_x <= _range_min) || (_x >= _range_max)){
        return 0;
      }
    }
    return _aux.evaluate(_x,_coefList);
  }

  Int_t DooCubicSplinePdf::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName) const
  {
    // No analytical calculation available (yet) of integrals over subranges
    if (_x.min(rangeName)!=_aux.knots().front() || _x.max(rangeName)!=_aux.knots().back() ) return 0;
    if (matchArgs(allVars, analVars, _x)) return 1;
    return 0;
  }

  Double_t DooCubicSplinePdf::analyticalIntegral(Int_t code, const char* /* rangeName */) const
  {
    assert(code==1) ;
    return _aux.analyticalIntegral(_coefList);
  }

  Int_t DooCubicSplinePdf::getMaxVal(const RooArgSet& vars) const
  {
      // check that vars only contains _x...
      return ( vars.getSize() == 1 && vars.contains( _x.arg() ) ) ? 1 : 0;
  }

  Double_t DooCubicSplinePdf::maxVal(Int_t code) const
  {
      assert(code==1);
      RooFIter iter = _coefList.fwdIterator();
      RooAbsReal *c(0);
      double res = 0;
      while((c=(RooAbsReal*)iter.next())) {
            double x = fabs(c->getVal());
            if (x>res)  { res = x; }
      }
      return res;
  }

}
}
}

