/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "TwoTaggerMistagCalibrationAndCombination.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(TwoTaggerMistagCalibrationAndCombination) 

namespace doofit {
namespace roofit {
namespace functions {

 TwoTaggerMistagCalibrationAndCombination::TwoTaggerMistagCalibrationAndCombination(const char *name, const char *title, 
                        RooAbsReal& _eta_one_,
                        RooAbsReal& _eta_two_,
                        RooAbsReal& _p0_one_,
                        RooAbsReal& _p0_two_,
                        RooAbsReal& _p1_one_,
                        RooAbsReal& _p1_two_,
                        RooAbsReal& _avg_eta_one_,
                        RooAbsReal& _avg_eta_two_,
                        RooAbsCategory& _tag_one_,
                        RooAbsCategory& _tag_two_) :
   RooAbsReal(name,title), 
   eta_one_("eta_one_","eta_one_",this,_eta_one_),
   eta_two_("eta_two_","eta_two_",this,_eta_two_),
   p0_one_("p0_one_","p0_one_",this,_p0_one_),
   p0_two_("p0_two_","p0_two_",this,_p0_two_),
   p1_one_("p1_one_","p1_one_",this,_p1_one_),
   p1_two_("p1_two_","p1_two_",this,_p1_two_),
   avg_eta_one_("avg_eta_one_","avg_eta_one_",this,_avg_eta_one_),
   avg_eta_two_("avg_eta_two_","avg_eta_two_",this,_avg_eta_two_),
   tag_one_("tag_one_","tag_one_",this,_tag_one_),
   tag_two_("tag_two_","tag_two_",this,_tag_two_)
 { 
 } 


 TwoTaggerMistagCalibrationAndCombination::TwoTaggerMistagCalibrationAndCombination(const TwoTaggerMistagCalibrationAndCombination& other, const char* name) :  
   RooAbsReal(other,name), 
   eta_one_("eta_one_",this,other.eta_one_),
   eta_two_("eta_two_",this,other.eta_two_),
   p0_one_("p0_one_",this,other.p0_one_),
   p0_two_("p0_two_",this,other.p0_two_),
   p1_one_("p1_one_",this,other.p1_one_),
   p1_two_("p1_two_",this,other.p1_two_),
   avg_eta_one_("avg_eta_one_",this,other.avg_eta_one_),
   avg_eta_two_("avg_eta_two_",this,other.avg_eta_two_),
   tag_one_("tag_one_",this,other.tag_one_),
   tag_two_("tag_two_",this,other.tag_two_)
 { 
 } 



 Double_t TwoTaggerMistagCalibrationAndCombination::evaluate() const 
 { 
   double omega_one = 0.5;
   double omega_two = 0.5;

   // calibrate first tagger
   omega_one = p0_one_ + p1_one_ * ( eta_one_ - avg_eta_one_ );
   // calibrate second tagger
   omega_two = p0_two_ + p1_two_ * ( eta_two_ - avg_eta_two_ );

   // calibrate taggers
   p_b = ( ( ( 1 + tag_one_ ) / 2 ) - tag_one_ * ( 1 - omega_one ) ) * ( ( ( 1 + tag_two_ ) / 2 ) - tag_two_ * ( 1 - omega_two ) );
   p_bbar = ( ( ( 1 - tag_one_ ) / 2 ) + tag_one_ * ( 1 - omega_one ) ) * ( ( ( 1 - tag_two_ ) / 2 ) + tag_two_ * ( 1 - omega_two ) );

   p_sum = p_b + p_bbar;

   

   return 1.0 ; 
 } 



 Int_t TwoTaggerMistagCalibrationAndCombination::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
 { 
   // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
   // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
   // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
   // EXPRESSION MULTIPLE TIMES

   // if (matchArgs(allVars,analVars,x)) return 1 ; 
   return 0 ; 
 } 



 Double_t TwoTaggerMistagCalibrationAndCombination::analyticalIntegral(Int_t code, const char* rangeName) const  
 { 
   // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
   // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
   // BOUNDARIES FOR EACH OBSERVABLE x

   // assert(code==1) ; 
   // return (x.max(rangeName)-x.min(rangeName)) ; 
   return 0 ; 
 } 

}
}
}



