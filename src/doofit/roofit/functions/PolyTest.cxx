/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "PolyTest.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(doofit::roofit::functions::PolyTest) 

namespace doofit {
namespace roofit {
namespace functions {

 PolyTest::PolyTest(const std::string name, 
                        RooAbsReal& _x_,
                        RooAbsReal& _c00_,
                        RooAbsReal& _c01_,
                        RooAbsReal& _c02_,
                        RooAbsReal& _c03_,
                        RooAbsReal& _c04_,
                        RooAbsReal& _c05_,
                        RooAbsReal& _c06_,
                        RooAbsReal& _c07_,
                        RooAbsReal& _c08_,
                        RooAbsReal& _c09_,
                        RooAbsReal& _c10_,
                        RooAbsReal& _c11_,
                        RooAbsReal& _c12_,
                        RooAbsReal& _c13_,
                        RooAbsReal& _c14_,
                        RooAbsReal& _c15_) :
   RooAbsPdf(name.c_str(),name.c_str()), 
   x_("x_","x_",this,_x_),
   c00_("c00_","c00_",this,_c00_),
   c01_("c01_","c01_",this,_c01_),
   c02_("c02_","c02_",this,_c02_),
   c03_("c03_","c03_",this,_c03_),
   c04_("c04_","c04_",this,_c04_),
   c05_("c05_","c05_",this,_c05_),
   c06_("c06_","c06_",this,_c06_),
   c07_("c07_","c07_",this,_c07_),
   c08_("c08_","c08_",this,_c08_),
   c09_("c09_","c09_",this,_c09_),
   c10_("c10_","c10_",this,_c10_),
   c11_("c11_","c11_",this,_c11_),
   c12_("c12_","c12_",this,_c12_),
   c13_("c13_","c13_",this,_c13_),
   c14_("c14_","c14_",this,_c14_),
   c15_("c15_","c15_",this,_c15_)
 { 
 } 


 PolyTest::PolyTest(const PolyTest& other, const char* name) :  
   RooAbsPdf(other,name), 
   x_("x_",this,other.x_),
   c00_("c00_",this,other.c00_),
   c01_("c01_",this,other.c01_),
   c02_("c02_",this,other.c02_),
   c03_("c03_",this,other.c03_),
   c04_("c04_",this,other.c04_),
   c05_("c05_",this,other.c05_),
   c06_("c06_",this,other.c06_),
   c07_("c07_",this,other.c07_),
   c08_("c08_",this,other.c08_),
   c09_("c09_",this,other.c09_),
   c10_("c10_",this,other.c10_),
   c11_("c11_",this,other.c11_),
   c12_("c12_",this,other.c12_),
   c13_("c13_",this,other.c13_),
   c14_("c14_",this,other.c14_),
   c15_("c15_",this,other.c15_)
 { 
 } 

 // Define per-bin functions
 Double_t PolyTest::F1(double x) const
 {
   // return TMath::Power(x, 4);
   return c00_ + c01_ * x + c02_ * TMath::Power(x, 2) + c03_ * TMath::Power(x, 3);
 }

 Double_t PolyTest::F2(double x) const
 {
   // return c0_ * TMath::Power(x, 3) + TMath::Power(x, 4);
   return c04_ * x + c05_ * TMath::Power(x, 2) + c06_ * TMath::Power(x, 3);
 }

 Double_t PolyTest::F3(double x) const
 {
   // return c1_ + TMath::Power(x, 1);
   return c07_ * x + c08_ * TMath::Power(x, 2) + c09_ * TMath::Power(x, 3);
 }

 Double_t PolyTest::F4(double x) const
 {
   // return c2_ * TMath::Power(x, 4) + c3_ * TMath::Power(x, 5) - TMath::Power(x, 6);
   return c10_ * x + c11_ * TMath::Power(x, 2) + c12_ * TMath::Power(x, 3);
 }

 Double_t PolyTest::F5(double x) const
 {
   // return c4_ * TMath::Power(x, 3) + c5_ * TMath::Power(x, 4) + c6_ * TMath::Power(x, 5) + c7_ * TMath::Power(x, 6);
   return c12_ * x + c13_ * TMath::Power(x, 2) + c14_ * TMath::Power(x, 3);
 }

 Double_t PolyTest::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 
   // return c0_ + c1_ * TMath::Power(x_, 1) + c2_ *  TMath::Power(x_, 2) + c3_ * TMath::Power(x_, 3) + c4_ * TMath::Power(x_, 4) + c5_ * TMath::Power(x_, 5) + c6_ * TMath::Power(x_, 6); 

   // per-bin normalisation
   double n1 = 1;
   double n2 = n1 * F1(0.15) / F2(0.15);
   double n3 = n2 * F2(0.20) / F3(0.20);
   double n4 = n3 * F3(0.28) / F4(0.28);
   double n5 = n4 * F4(0.46) / F5(0.46);

   if (x_<=0.07){
      return 0;
   }
   else if ((x_>0.07) && (x_<=0.15)){
      return n1 * F1(x_);
   }
   else if ((x_>0.15) && (x_<=0.20)){
      return n2 * F2(x_);
   }
   else if ((x_>0.20) && (x_<=0.28)){
   
      return n3 * F3(x_);
   }
   else if ((x_>0.28) && (x_<=0.46)){
   
      /// n4 = (0,016 + 0,2) / (0,2 * 0,00707281 + 0,16 * 0,002051115 - 0,000594823) = 
      return n4 * F4(x_); 
   }
   else if ((x_>0.46) && (x_<=0.50)){
   
      return n5 * F5(x_); 
   }
   return 0;
 } 



 Int_t PolyTest::getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* /*rangeName*/) const  
 { 
   // LIST HERE OVER WHICH VARIABLES ANALYTICAL INTEGRATION IS SUPPORTED, 
   // ASSIGN A NUMERIC CODE FOR EACH SUPPORTED (SET OF) PARAMETERS 
   // THE EXAMPLE BELOW ASSIGNS CODE 1 TO INTEGRATION OVER VARIABLE X
   // YOU CAN ALSO IMPLEMENT MORE THAN ONE ANALYTICAL INTEGRAL BY REPEATING THE matchArgs 
   // EXPRESSION MULTIPLE TIMES

   std::printf("In %s line %u (%s): allVars = ", __func__, __LINE__, __FILE__);
   analVars.Print();

   return 0 ; 
 } 



 Double_t PolyTest::analyticalIntegral(Int_t code, const char* rangeName) const  
 { 
   // RETURN ANALYTICAL INTEGRAL DEFINED BY RETURN CODE ASSIGNED BY getAnalyticalIntegral
   // THE MEMBER FUNCTION x.min(rangeName) AND x.max(rangeName) WILL RETURN THE INTEGRATION
   // BOUNDARIES FOR EACH OBSERVABLE x

   // assert(code==1) ; 
   // return (x.max(rangeName)-x.min(rangeName)); 
   return 0 ; 
 } 

}
}
}

